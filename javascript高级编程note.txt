element.normalize();这个方法能够把内部元素的节点合并成一个节点
element.firstChlid;获取元素的文本节点
element.firstChild.nodeType;节点类型
element.firstChild.nodeName;节点名称
element.firstChild.parent;是一个元素
element.firstChild.appendData(text);将text添加到节点的末尾
element.firstChild.deleteData(offset, count);从offset指定的位置删除count个节点
element.firstChild.insetData(offset, text);从offset指定的位置插入text
element.firstChild.replaceData(offset, count, text);人offset处删除到count文本并替换成text
element.firstChild.splitText(offset);从offset指定的位置将当前文本切割成几个元素 
element.firstChild.substringData(offset, count);从offset提到count个文本字符串


comment 注释节点
	节点类型为 8 因其无法通过类名与ID名称查找 可以通过赢遍厉所有的元素来查找注释点节
	属性有nodType nodeName nodeValue parentNode


节点 
	document
	nodeType的值为10;
	nodeName的值为doctype的名称;
	nodeValue的值为null;
	parentNode是document;

节点documentFragment
	nodeType的值为11；
	nodeName的值为"#document-fragment";
	nodeValue的值为null
	parentNode的值为null;
	子节点可以是element,processingInstruction, comment, text, CDATASection, EntityReference

	var fragment = document.createDocumentFragment();
	可以保存需要添加到文档中的节点;

	例：
		var fragment = document.createDocumentFragment();
	var ul = document.createElement("ul");
	var ulT = document.createTextNode("sfaasf");
	var li = document.createElement("li");
	var liT = document.createTextNode("asfsd");
	ul.appendChild(ulT);
	ul.appendChild(li);
	li.appendChild(liT);
	fragment.appendChild(ul);
	document.body.appendChild(fragment);

节点attr 
	nodeType的值为11;
	nodeName的值是特性的名称;
	nodeValue的值是特性的值;
	parentNode的值为null;
	
	Attr有三个属性name value specified
	name 是nodeName value是nodeValue
	var attr = document.createAttribute("align");
	attr.value = "left";
	element.setAttributeNode(attr);
	element.attributes['align'].value;
	element.getAttributeNode['align'].value;
	element.getAttribute("align" )


动态的创建脚本
	var scri = document.getElementsByTagName("script")[0];
	loadScript("excel.js", scri);
	function loadScript(url, ro){
		var script = document.createElement("script");
		script.type = "text/javascript";
		script.src = url;
		document.body.appendChild(script);
		document.head.removeChild(ro);
	}

动态的创建执行脚本
	var script = document.createElement("script");
	script.type = "text/javascript";
	var text = "var r = function(){alert('read')}";
	try{
		script.appendChild(document.createTextNode(text));
	}catch(er){
		script.text = text';
	}

动态的创建样式
	function loadStyles(url){
		var link = document.createElement("link");
		link.rel = "stylesheet";
		link.type = "text/css";
		link.href = url;
		var head = document.getElementsByTagName("head")[0];
		head.appendChild(link);
	}	

动态的创建执行样式
	function loadStyleString(css){
		var style = document.createElement("style");
		style.type = "text/cxx";
		try{
			style.appendChild(document.createTextNode(css));
		}catch(err){
			// 在使用styleSheet.cssText时需要注意这个代码重用会导制浏览器崩溃
			style.styleSheet.cssText = css;
		}
		var head = document.getElementsByTagName("haed")[0];
		head.appendChild(style);
	}	

表格

	var table = document.createElement("table");
	table.border = 1;
	table.width = "100%";

	// 创建tbody;
	var tbody = document.createElement("tbody");
	table.appendChild(tbody);

	// 创建第一行
	var row1 = document.createElement("tr");
	tbody.appendChild(row1);
	var cell1_1 = document.createElement("td");
	cell1_1.appendChild(document.createTextNode("Cell 1.1"));
	row1.appendChild(cell1_1);
	var cell2_1 = document.createElement("td");
	cell2_1.appendChild(document.createTextNode("Cell 2,1"));
	row1.appendChild(cell2_1);

	// 创建第二行
	var row2 = document.createElement("tr");
	tbody.appendChild(row2);
	var tell1_2 = document.createElement("td");
	tell1_2.appendChild(document.createTextNode("Cell 1,2"));
	row2.appendChild(tell1_2);
	var cell2_2 = document.createElement("td");
	cell2_2.appendChild(document.createTextNode("Cell 2, 2"));
	row2.appendChild(cell2_2);
	
	// 将表格添加到文档主体中
	document.body.appendChild(table);

	caption: 保存着对<caption>元素（如果有）的指针
	tBodies: 是一个:<tbody>元素的HTMLCollection;
	tFoot: 保存着对<tfoot>元素(如果有)的指针
	tHead: 保存着对<thead>元素（如果有）的指针
	rows: 是一个表格中所有行的HTMLCollection;
	createTHead(): 创建<thead>元素，将其放到表格中，返回引用
	createTFoot(): 创建<tfoot>元素，将期放到表格中，返回引用
	createCaption(): 创建<caption>元素，将期放到表格中，返回引用
	deleteThead(): 删除<thead>元素。
	deleteTFoot: 删除<tfoot>元素。
	deleteCaption(): 删除<caption>元素
	deleteRow(pos): 删除指定位置的行.
	insertRow(pos): 向rows集合中的指定位置插入一行
	rows: 保存着<tbody> 元素中行的HTMLCollection。
	deleteRow(pos): 删除指定位置的行。
	insertRow(pops): 向rows 集合中的指定位置插入一行 返回引用、
	cells: 保存着<tr>元素中单元格的HTMLCollection.
	deleteCell(pos): 删除指定位的单元格	
	insertCell(pos): 向cells集合中插入一个单元格 返回引用

	
	var table = document.createElement("table");
	table.border = 1;
	table.width = "100%";

	// 创建tbody;
	var tbody = document.createElement("tbody");
	table.appendChild(tbody);

	// 创建第一行
	tbody.insertRow(0);
	tbody.rows[0].insertCell(0);
	tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1"));
	tbody.rows[0].insertCell(1);
	tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2"));

	// 创建第二行
	tbody.insertRow(1);
	tbody.rows[1].insertCell(0);
	tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 3"));
	tbody.rows[1].insertCell(1);
	tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 4"));

	document.body.appendChild(table)


	与客户沟通本着两个原则
	1，考虑客户需求
	2，考虑自身利益


DOM扩展
	document.querySelector("body");
	查找API兼容经测试能兼容主流浏览器
	document.querySelectorAll("p") 查找所有的p标签
	// DOM确认API
	function matchesSelector(element, selector){
		if(element.matchesSelector){
			return element.matchesSelector(selector);
		}else if(element.msMatchesSelector){
			return element.msMatchesSelector(selector)
		}else if(element.mozMathesSelector){
			return element.mozMathcesSelector(selector)
		}else if(element.webkitMathesSelector){
			return element.webkitMatchesSelector(selector);
		}else{
			throw new Error("Not supported.")
		}
	}
	
	element.childElementCount 返回子元素个数不包括文本跟注释节点
	element.firstElementChild 指向第一个子元素
	element.lastElementChild 指向最后一个子元素
	previousElementSibling 指向前一个同辈元素
	nextElementSibling 指向后一个同辈元素

	
	var i,
		len,
		child = element.firstChild;
	while(child != element.lastChild){
		if(child.nodeType == 1){
			processChild(child);
		}
		child = child.nextSibling;
	}
	var i,
		len,
		child = element.firstElementChild;
	while(child != element.lastElementChild){
		processChild(child);
		child = child.nextSibling;
	}
	

类的操作
	var div = document.getElementsByClassName("user name");	
	var classNames = div.className.split(/\s+/);


	// 找到要删的类名
	var pos = -1,
		i,
		len;
	for(i = 0,len = classNames.length;i < len; i++){
		if(classNames[i] == deleteClassName){
			pos = i;
		}
	}
	
	classNames.splice(i, 1);
	
	// 通过document.getElementsByClassName()这个方法获取到的元素会有一个classList的属性保存着所有的类名其类名有以下几种操作方法
	add(value)：将给定的字符串值添车到列表中，如果值存在就不添加
	contains(value): 表示列表中是否给定存在的值，如果存在返回true，否则返回false
	remove(value): 从列表中删除给定的字符串
	toggle(value): 如果列表中已存在的值就删除他否则就添加

焦点管理
	var buton = document.getElementsByTagName("button");
	button.focus();
	alert(document.activeElement === button); // true

	// 可以判断元素是否处理焦点状态
	document.hasFocus();

	
	// document有readyState属性，这个属性的值有两种，第一种为loading,正在加载文档,complete，已经加载文档
	if(document.readyState == "complete"){
		// 执行操作
	}
	
兼容模式
	// document.compatMode 有两个值为CSS1Compat是标准模式，BackCompat是混杂模式
	if(document.compatMode == "CSS1Compat"){
		alert("Standards mode");
	}else{
		alert("Quirks mode")
	}

字符集属性
	// document.charset 可以获取与设置网页字符集，
	// 如果在head里设置了charset的格式，那么这个属性只能获取charset格式
	

// 自定义数据属性
	<div id="myDiv" data-appId = "12345" data-myname = "Nicholas"></div>
		var div = document.getElementById("myDiv");
	
	// 取得自定义属性的值
	var appId = div.dataset.appId;
	var myName = div.dataset.myname;
	
	// 设置值
	div.dataset.appId = 23456;
	div.dataset.myname = "Michael";

	// 有没有"myname"值呢
	if(div.dataset.myname){
		alert("hello ," + div.dataset.myname);
	}
	
// innerHTML 
	<div id="content">hello &amp; welcome, <b>&quot;reader&quot;!</b></div>
	var div = document.getElementById("content");
	// 因为innerHTML是为C++编写的，所以运行速度会更快，会更占内存，所有尽可能的少用innerHTML
	// 用innerHTML添加script时需要有域支持因为用innerHTML创建出来的元素是没有域的所以有以下三种方法来处理这种域的处理
	div.innerHTML = "_<script defer>alert('hi')<\/script>";
	div.innerHTML = "<div>&nbsp;</div><script defer>alert('hi')<\/script>"
	div.innerHTML = "<input type=\"hidden\"><script>alert('hi')<\/script>"

	// 在IE8以前style也是一个没有域的元素所以也可以通过以上方法来添加域
	还有一些元素不支持innerHTML例如<col>,<colgroup>,<framese>,<head>,<html>,<style>,
	<table>,<tbody>,<thead>,<tfoot>,<tr>,<title>

// toStaticHTML fn
	// 只有IE8才支持这个方法
	var text = "<a href=\"javascript:;\" onclick=\"alert('hi')\">Click ME</a>";
	var sanitized = window.toStaticHTML(text);
	alert(sanitized);

// outerHTML
	使用方法同innerHTML,不同的是outerHTML 会替换当前调用此方法的元素

// insertAdjacentHTML();

	"beforebegin":在当前元素之前插入一个紧邻的同辈元素
	"afterbegin":在当前元素之下插入一个新的子元素或在第一个子元素之前再插入子元素
	"beforeend":在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入子元素
	"afterend":在当前元素之后插入一个紧邻的同辈元素

	// 作为前一个同辈元素插入
	element.insertAdjecntHTML("beforebegin" "<p>hello world!</p>");

	// 作为第一个子元素插入
	element.insertAdjecntHTML("afterbegin", "<p>Hello world!</p>");

	// 作为最后一个子元素插入
	element.insertAdjacentHTML("beforeend", "<p>hello world!</p>");
	
	// 作为后一个同辈元素插入
	element.insertAdjacentHTML("afterend", "<p>Hello world!</p>");

// scrollIntoView()
	// 把可视窗口调到第一个form的位置
	document.forms[0].scrollIntoView();
	
// 文档模式
	// content的值可以为以下几种
	Edge: 始终以最新的文档模式来渲染页面，忽略文档类型声明，对于IE8，始终保持IE8的标准模式渲染页面，对于IE9，则以IE9的标准模式渲染页面
	EmulateIE9: 如果有文档类型声明，则以IE9标准模式渲染页面
	EmulateIE8: 如果有文档类型声明，则以IE8标准模式渲染页面
	EmulateIE7: 如果有文档类型声明，则以IE7标准模式渲染页面
	9: 强制以IE9标准模式渲染页面，忽略文档类型声明
	8: 强制以IE8标准模式渲染页面，忽略文档类型声明
	7: 强制以IE7标准模式渲染页面，忽略文档类型声明
	// ie6无法通过此种类型设置
	5: 强制将当模式设为IE5，忽略类型声明
	<meta http-equiv="X-UA-Compatible" content="ie=IEVersion">
	// 此属性可以获取浏览器的文档模式
	var mode = document.documentMode;

// children
	// 这个属性出现的原因是因为浏览器在处理文本节点中的空白符时有差异，这个属笥是HTMLCollection的实例
	／／　这个属性与ｃｈｉｌｄＮodes没什么区别　
	element.children.length;
	